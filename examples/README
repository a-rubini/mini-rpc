
	trivial-server and trivial-client
	---------------------------------

These two were called sample-server and sample-client in earlier
snapshots of the package (when no examples subdirectory existed).

The server exports three functions:

    sum: it receives two integers and returns integer

    gettimeofday: it receives nothing and returns struct timeval

    sqrt: it receives one double and returns one double

The server shows how the minipc_pd structures are built and how the
minipc_f function is implemented.  The first function in the file is a
non-rpc aware function, properly wrapped by the second function.

In this case the main loop of the server is simply calling the
server action, without doing anything else. It is verbose in its
own looping and declares stderr as logfile for the library.


The client declares the same "struct minipc_pd" as the server (more
serious users should define them in a separate object file so they
would be shared). It simply calls the server functions a few times,
with a 0.5s delay between each call.

You can test it like this from two different terminal sessions:

    ./trivial-server

    for n in $(seq 1 20); do
        ./trivial-client &
	 sleep 0.2
    done



	pty-server and pty-client
	-------------------------

This is a more complete example. It shows how to multiplex rpc
operations and other operations by using th rpc fd_set together with
your own channels.

The server creates a pty and runs an underlying shell. If feeds its
own stdin to the shell and the shell's stdout to its own stdout.  Call
it with no arguments. It logs to /tmp/pty-server.XXXXXX, created with
mkstemp().

The rpc client (called pty-client) can ask for the statistics of
bytes read/written in the new pty that has been created, can read
or write environment variables in the pty-server application, it
can feed strings to the shell driven by the pty server, run strlen
and strcat remotely, and remotely
run the stat system call (to check string and structure exchange).  Each
pty-client run takes a commandline, like this:

	./pty-client count
	./pty-client getenv <name>
	./pty-client setenv <name> <value>
	./pty-client feed <shell-command>
	./pty-client strlen <string>
	./pty-client strcat <string> <string>
	./pty-client stat <filename>

The commands count, feed, strlen, strcat and stat can be verified
by just inspecting the output. The setenv command and getenv commands
can be cross-verified.

Note that only one pty-server can be running at a time (as the rpc
socket is a static name).

The sharing of minipc_pd (procedure description) is accomplished by
linking the same object file in both programs, to avoid code duplication.


	mbox-bridge and friends
	-----------------------

The "mailbox-bridge" example shows how to route mini-ipc requests to
another process through shared memory. Sure there is no real interest
in shared memory, but the same approach can be used with mailbox-kind
communication mechanisms to talk with hardware, or a CPU without OS
running on FPGA.

This example is made up of three programs:

     mbox-bridge: acts both as a server and a client of the mini-ipc
     protocol, routing requests to and from a shared-memory mailbox.
     As mini-ipc client, it requests the current time to trivial-server.
     As mini-ipc server, it replies to stat(2) calls for local filenames.

     mbox-process: the "remote" process, only communicating though
     the mailbox device. It asks for the current time once a
     secondo and can serve stat(2) requests when they happen.

     mbox-client: a program that reads stdin forever, asking a
     stat(2) for every line it reads.

To demonstrate the mechanism, you'll need to run trivial-server (which
answers timeofday() queries), mbox-bridge (to bridge requests),
mbox-process and one or more mbox-client processes.

This an example output from mbox-bridge (which passes gettimeofday
requests silently, but uses mini-ipc verbose logging to stderr:

   minipc_export: exported 0x8a3d228 (stat) with pd 0x804a1a0
                   -- retval 00050058, args 00040004...
   mpc_handle_connection: accept returned fd 5 (error 0)
   mpc_handle_client: request for stat
   mpc_handle_client: request for stat
   mpc_handle_client: request for stat
   mpc_handle_client: error 0 in fd 5, closing
   mpc_handle_connection: accept returned fd 5 (error 0)
   mpc_handle_client: request for stat
   mpc_handle_client: request for stat
   mpc_handle_client: error 0 in fd 5, closing
   mpc_handle_connection: accept returned fd 5 (error 0)
   mpc_handle_connection: accept returned fd 6 (error 0)
   mpc_handle_client: request for stat
   mpc_handle_client: error 0 in fd 6, closing

This is the output from mbox-process, which reports all actions:

   time: 1326231447.212400
   time: 1326231448.218001
   time: 1326231449.233714
   Serving stat(/home/rubini)
   time: 1326231450.240125

And this is what happened in one of the mbox-client:

   /home/rubini
   minipc_call: calling "stat"
   /home/rubini:
   mode 40755, size 32768, owner 410, atime 1326230999
